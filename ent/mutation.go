// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"time"

	"github.com/ErrorBoi/feedparserbot/ent/globalsettings"
	"github.com/ErrorBoi/feedparserbot/ent/post"
	"github.com/ErrorBoi/feedparserbot/ent/schema"
	"github.com/ErrorBoi/feedparserbot/ent/source"
	"github.com/ErrorBoi/feedparserbot/ent/user"
	"github.com/ErrorBoi/feedparserbot/ent/usersettings"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeGlobalsettings = "Globalsettings"
	TypePost           = "Post"
	TypeSource         = "Source"
	TypeUser           = "User"
	TypeUserSettings   = "UserSettings"
)

// GlobalsettingsMutation represents an operation that mutate the GlobalsettingsSlice
// nodes in the graph.
type GlobalsettingsMutation struct {
	config
	op              Op
	typ             string
	id              *int
	clickbait_words *[]string
	clearedFields   map[string]struct{}
}

var _ ent.Mutation = (*GlobalsettingsMutation)(nil)

// newGlobalsettingsMutation creates new mutation for $n.Name.
func newGlobalsettingsMutation(c config, op Op) *GlobalsettingsMutation {
	return &GlobalsettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeGlobalsettings,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GlobalsettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GlobalsettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GlobalsettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClickbaitWords sets the clickbait_words field.
func (m *GlobalsettingsMutation) SetClickbaitWords(s []string) {
	m.clickbait_words = &s
}

// ClickbaitWords returns the clickbait_words value in the mutation.
func (m *GlobalsettingsMutation) ClickbaitWords() (r []string, exists bool) {
	v := m.clickbait_words
	if v == nil {
		return
	}
	return *v, true
}

// ClearClickbaitWords clears the value of clickbait_words.
func (m *GlobalsettingsMutation) ClearClickbaitWords() {
	m.clickbait_words = nil
	m.clearedFields[globalsettings.FieldClickbaitWords] = struct{}{}
}

// ClickbaitWordsCleared returns if the field clickbait_words was cleared in this mutation.
func (m *GlobalsettingsMutation) ClickbaitWordsCleared() bool {
	_, ok := m.clearedFields[globalsettings.FieldClickbaitWords]
	return ok
}

// ResetClickbaitWords reset all changes of the clickbait_words field.
func (m *GlobalsettingsMutation) ResetClickbaitWords() {
	m.clickbait_words = nil
	delete(m.clearedFields, globalsettings.FieldClickbaitWords)
}

// Op returns the operation name.
func (m *GlobalsettingsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Globalsettings).
func (m *GlobalsettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GlobalsettingsMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.clickbait_words != nil {
		fields = append(fields, globalsettings.FieldClickbaitWords)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GlobalsettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case globalsettings.FieldClickbaitWords:
		return m.ClickbaitWords()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GlobalsettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case globalsettings.FieldClickbaitWords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClickbaitWords(v)
		return nil
	}
	return fmt.Errorf("unknown Globalsettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GlobalsettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GlobalsettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GlobalsettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Globalsettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GlobalsettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(globalsettings.FieldClickbaitWords) {
		fields = append(fields, globalsettings.FieldClickbaitWords)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GlobalsettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GlobalsettingsMutation) ClearField(name string) error {
	switch name {
	case globalsettings.FieldClickbaitWords:
		m.ClearClickbaitWords()
		return nil
	}
	return fmt.Errorf("unknown Globalsettings nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GlobalsettingsMutation) ResetField(name string) error {
	switch name {
	case globalsettings.FieldClickbaitWords:
		m.ResetClickbaitWords()
		return nil
	}
	return fmt.Errorf("unknown Globalsettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GlobalsettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GlobalsettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GlobalsettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GlobalsettingsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GlobalsettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GlobalsettingsMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GlobalsettingsMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Globalsettings unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GlobalsettingsMutation) ResetEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Globalsettings edge %s", name)
}

// PostMutation represents an operation that mutate the Posts
// nodes in the graph.
type PostMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	title                *string
	title_translations   *schema.Translations
	subject              *string
	subject_translations *schema.Translations
	url                  *string
	published_at         *time.Time
	description          *string
	h1                   *string
	content              *string
	created_at           *time.Time
	updated_at           *time.Time
	updated_by           *int
	addupdated_by        *int
	clearedFields        map[string]struct{}
	source               *int
	clearedsource        bool
}

var _ ent.Mutation = (*PostMutation)(nil)

// newPostMutation creates new mutation for $n.Name.
func newPostMutation(c config, op Op) *PostMutation {
	return &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PostMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTitle sets the title field.
func (m *PostMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *PostMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// ResetTitle reset all changes of the title field.
func (m *PostMutation) ResetTitle() {
	m.title = nil
}

// SetTitleTranslations sets the title_translations field.
func (m *PostMutation) SetTitleTranslations(s schema.Translations) {
	m.title_translations = &s
}

// TitleTranslations returns the title_translations value in the mutation.
func (m *PostMutation) TitleTranslations() (r schema.Translations, exists bool) {
	v := m.title_translations
	if v == nil {
		return
	}
	return *v, true
}

// ResetTitleTranslations reset all changes of the title_translations field.
func (m *PostMutation) ResetTitleTranslations() {
	m.title_translations = nil
}

// SetSubject sets the subject field.
func (m *PostMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the subject value in the mutation.
func (m *PostMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubject clears the value of subject.
func (m *PostMutation) ClearSubject() {
	m.subject = nil
	m.clearedFields[post.FieldSubject] = struct{}{}
}

// SubjectCleared returns if the field subject was cleared in this mutation.
func (m *PostMutation) SubjectCleared() bool {
	_, ok := m.clearedFields[post.FieldSubject]
	return ok
}

// ResetSubject reset all changes of the subject field.
func (m *PostMutation) ResetSubject() {
	m.subject = nil
	delete(m.clearedFields, post.FieldSubject)
}

// SetSubjectTranslations sets the subject_translations field.
func (m *PostMutation) SetSubjectTranslations(s schema.Translations) {
	m.subject_translations = &s
}

// SubjectTranslations returns the subject_translations value in the mutation.
func (m *PostMutation) SubjectTranslations() (r schema.Translations, exists bool) {
	v := m.subject_translations
	if v == nil {
		return
	}
	return *v, true
}

// ClearSubjectTranslations clears the value of subject_translations.
func (m *PostMutation) ClearSubjectTranslations() {
	m.subject_translations = nil
	m.clearedFields[post.FieldSubjectTranslations] = struct{}{}
}

// SubjectTranslationsCleared returns if the field subject_translations was cleared in this mutation.
func (m *PostMutation) SubjectTranslationsCleared() bool {
	_, ok := m.clearedFields[post.FieldSubjectTranslations]
	return ok
}

// ResetSubjectTranslations reset all changes of the subject_translations field.
func (m *PostMutation) ResetSubjectTranslations() {
	m.subject_translations = nil
	delete(m.clearedFields, post.FieldSubjectTranslations)
}

// SetURL sets the url field.
func (m *PostMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the url value in the mutation.
func (m *PostMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// ResetURL reset all changes of the url field.
func (m *PostMutation) ResetURL() {
	m.url = nil
}

// SetPublishedAt sets the published_at field.
func (m *PostMutation) SetPublishedAt(t time.Time) {
	m.published_at = &t
}

// PublishedAt returns the published_at value in the mutation.
func (m *PostMutation) PublishedAt() (r time.Time, exists bool) {
	v := m.published_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetPublishedAt reset all changes of the published_at field.
func (m *PostMutation) ResetPublishedAt() {
	m.published_at = nil
}

// SetDescription sets the description field.
func (m *PostMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the description value in the mutation.
func (m *PostMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// ResetDescription reset all changes of the description field.
func (m *PostMutation) ResetDescription() {
	m.description = nil
}

// SetH1 sets the h1 field.
func (m *PostMutation) SetH1(s string) {
	m.h1 = &s
}

// H1 returns the h1 value in the mutation.
func (m *PostMutation) H1() (r string, exists bool) {
	v := m.h1
	if v == nil {
		return
	}
	return *v, true
}

// ResetH1 reset all changes of the h1 field.
func (m *PostMutation) ResetH1() {
	m.h1 = nil
}

// SetContent sets the content field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the content value in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// ResetContent reset all changes of the content field.
func (m *PostMutation) ResetContent() {
	m.content = nil
}

// SetCreatedAt sets the created_at field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the created_at value in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetCreatedAt reset all changes of the created_at field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the updated_at field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the updated_at value in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// ResetUpdatedAt reset all changes of the updated_at field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the updated_by field.
func (m *PostMutation) SetUpdatedBy(i int) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the updated_by value in the mutation.
func (m *PostMutation) UpdatedBy() (r int, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// AddUpdatedBy adds i to updated_by.
func (m *PostMutation) AddUpdatedBy(i int) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the updated_by field in this mutation.
func (m *PostMutation) AddedUpdatedBy() (r int, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of updated_by.
func (m *PostMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[post.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the field updated_by was cleared in this mutation.
func (m *PostMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[post.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy reset all changes of the updated_by field.
func (m *PostMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, post.FieldUpdatedBy)
}

// SetSourceID sets the source edge to Source by id.
func (m *PostMutation) SetSourceID(id int) {
	m.source = &id
}

// ClearSource clears the source edge to Source.
func (m *PostMutation) ClearSource() {
	m.clearedsource = true
}

// SourceCleared returns if the edge source was cleared.
func (m *PostMutation) SourceCleared() bool {
	return m.clearedsource
}

// SourceID returns the source id in the mutation.
func (m *PostMutation) SourceID() (id int, exists bool) {
	if m.source != nil {
		return *m.source, true
	}
	return
}

// SourceIDs returns the source ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SourceID instead. It exists only for internal usage by the builders.
func (m *PostMutation) SourceIDs() (ids []int) {
	if id := m.source; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSource reset all changes of the source edge.
func (m *PostMutation) ResetSource() {
	m.source = nil
	m.clearedsource = false
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.title != nil {
		fields = append(fields, post.FieldTitle)
	}
	if m.title_translations != nil {
		fields = append(fields, post.FieldTitleTranslations)
	}
	if m.subject != nil {
		fields = append(fields, post.FieldSubject)
	}
	if m.subject_translations != nil {
		fields = append(fields, post.FieldSubjectTranslations)
	}
	if m.url != nil {
		fields = append(fields, post.FieldURL)
	}
	if m.published_at != nil {
		fields = append(fields, post.FieldPublishedAt)
	}
	if m.description != nil {
		fields = append(fields, post.FieldDescription)
	}
	if m.h1 != nil {
		fields = append(fields, post.FieldH1)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, post.FieldUpdatedBy)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldTitle:
		return m.Title()
	case post.FieldTitleTranslations:
		return m.TitleTranslations()
	case post.FieldSubject:
		return m.Subject()
	case post.FieldSubjectTranslations:
		return m.SubjectTranslations()
	case post.FieldURL:
		return m.URL()
	case post.FieldPublishedAt:
		return m.PublishedAt()
	case post.FieldDescription:
		return m.Description()
	case post.FieldH1:
		return m.H1()
	case post.FieldContent:
		return m.Content()
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldUpdatedBy:
		return m.UpdatedBy()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case post.FieldTitleTranslations:
		v, ok := value.(schema.Translations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitleTranslations(v)
		return nil
	case post.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case post.FieldSubjectTranslations:
		v, ok := value.(schema.Translations)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubjectTranslations(v)
		return nil
	case post.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case post.FieldPublishedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublishedAt(v)
		return nil
	case post.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case post.FieldH1:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetH1(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PostMutation) AddedFields() []string {
	var fields []string
	if m.addupdated_by != nil {
		fields = append(fields, post.FieldUpdatedBy)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case post.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	case post.FieldUpdatedBy:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldSubject) {
		fields = append(fields, post.FieldSubject)
	}
	if m.FieldCleared(post.FieldSubjectTranslations) {
		fields = append(fields, post.FieldSubjectTranslations)
	}
	if m.FieldCleared(post.FieldUpdatedBy) {
		fields = append(fields, post.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldSubject:
		m.ClearSubject()
		return nil
	case post.FieldSubjectTranslations:
		m.ClearSubjectTranslations()
		return nil
	case post.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldTitle:
		m.ResetTitle()
		return nil
	case post.FieldTitleTranslations:
		m.ResetTitleTranslations()
		return nil
	case post.FieldSubject:
		m.ResetSubject()
		return nil
	case post.FieldSubjectTranslations:
		m.ResetSubjectTranslations()
		return nil
	case post.FieldURL:
		m.ResetURL()
		return nil
	case post.FieldPublishedAt:
		m.ResetPublishedAt()
		return nil
	case post.FieldDescription:
		m.ResetDescription()
		return nil
	case post.FieldH1:
		m.ResetH1()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.source != nil {
		edges = append(edges, post.EdgeSource)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgeSource:
		if id := m.source; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedsource {
		edges = append(edges, post.EdgeSource)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgeSource:
		return m.clearedsource
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgeSource:
		m.ClearSource()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgeSource:
		m.ResetSource()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// SourceMutation represents an operation that mutate the Sources
// nodes in the graph.
type SourceMutation struct {
	config
	op              Op
	typ             string
	id              *int
	url             *string
	title           *string
	language        *source.Language
	clearedFields   map[string]struct{}
	parent          *int
	clearedparent   bool
	children        map[int]struct{}
	removedchildren map[int]struct{}
	posts           map[int]struct{}
	removedposts    map[int]struct{}
	users           map[int]struct{}
	removedusers    map[int]struct{}
}

var _ ent.Mutation = (*SourceMutation)(nil)

// newSourceMutation creates new mutation for $n.Name.
func newSourceMutation(c config, op Op) *SourceMutation {
	return &SourceMutation{
		config:        c,
		op:            op,
		typ:           TypeSource,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SourceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SourceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SourceMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetURL sets the url field.
func (m *SourceMutation) SetURL(s string) {
	m.url = &s
}

// URL returns the url value in the mutation.
func (m *SourceMutation) URL() (r string, exists bool) {
	v := m.url
	if v == nil {
		return
	}
	return *v, true
}

// ResetURL reset all changes of the url field.
func (m *SourceMutation) ResetURL() {
	m.url = nil
}

// SetTitle sets the title field.
func (m *SourceMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the title value in the mutation.
func (m *SourceMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// ResetTitle reset all changes of the title field.
func (m *SourceMutation) ResetTitle() {
	m.title = nil
}

// SetLanguage sets the language field.
func (m *SourceMutation) SetLanguage(s source.Language) {
	m.language = &s
}

// Language returns the language value in the mutation.
func (m *SourceMutation) Language() (r source.Language, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// ResetLanguage reset all changes of the language field.
func (m *SourceMutation) ResetLanguage() {
	m.language = nil
}

// SetParentID sets the parent edge to Source by id.
func (m *SourceMutation) SetParentID(id int) {
	m.parent = &id
}

// ClearParent clears the parent edge to Source.
func (m *SourceMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared returns if the edge parent was cleared.
func (m *SourceMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the parent id in the mutation.
func (m *SourceMutation) ParentID() (id int, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the parent ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *SourceMutation) ParentIDs() (ids []int) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent reset all changes of the parent edge.
func (m *SourceMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the children edge to Source by ids.
func (m *SourceMutation) AddChildIDs(ids ...int) {
	if m.children == nil {
		m.children = make(map[int]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// RemoveChildIDs removes the children edge to Source by ids.
func (m *SourceMutation) RemoveChildIDs(ids ...int) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int]struct{})
	}
	for i := range ids {
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed ids of children.
func (m *SourceMutation) RemovedChildrenIDs() (ids []int) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the children ids in the mutation.
func (m *SourceMutation) ChildrenIDs() (ids []int) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren reset all changes of the children edge.
func (m *SourceMutation) ResetChildren() {
	m.children = nil
	m.removedchildren = nil
}

// AddPostIDs adds the posts edge to Post by ids.
func (m *SourceMutation) AddPostIDs(ids ...int) {
	if m.posts == nil {
		m.posts = make(map[int]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// RemovePostIDs removes the posts edge to Post by ids.
func (m *SourceMutation) RemovePostIDs(ids ...int) {
	if m.removedposts == nil {
		m.removedposts = make(map[int]struct{})
	}
	for i := range ids {
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed ids of posts.
func (m *SourceMutation) RemovedPostsIDs() (ids []int) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the posts ids in the mutation.
func (m *SourceMutation) PostsIDs() (ids []int) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts reset all changes of the posts edge.
func (m *SourceMutation) ResetPosts() {
	m.posts = nil
	m.removedposts = nil
}

// AddUserIDs adds the users edge to User by ids.
func (m *SourceMutation) AddUserIDs(ids ...int) {
	if m.users == nil {
		m.users = make(map[int]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// RemoveUserIDs removes the users edge to User by ids.
func (m *SourceMutation) RemoveUserIDs(ids ...int) {
	if m.removedusers == nil {
		m.removedusers = make(map[int]struct{})
	}
	for i := range ids {
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed ids of users.
func (m *SourceMutation) RemovedUsersIDs() (ids []int) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the users ids in the mutation.
func (m *SourceMutation) UsersIDs() (ids []int) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers reset all changes of the users edge.
func (m *SourceMutation) ResetUsers() {
	m.users = nil
	m.removedusers = nil
}

// Op returns the operation name.
func (m *SourceMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Source).
func (m *SourceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SourceMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.url != nil {
		fields = append(fields, source.FieldURL)
	}
	if m.title != nil {
		fields = append(fields, source.FieldTitle)
	}
	if m.language != nil {
		fields = append(fields, source.FieldLanguage)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SourceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case source.FieldURL:
		return m.URL()
	case source.FieldTitle:
		return m.Title()
	case source.FieldLanguage:
		return m.Language()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SourceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case source.FieldURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetURL(v)
		return nil
	case source.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case source.FieldLanguage:
		v, ok := value.(source.Language)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SourceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SourceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SourceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Source numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SourceMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SourceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SourceMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Source nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SourceMutation) ResetField(name string) error {
	switch name {
	case source.FieldURL:
		m.ResetURL()
		return nil
	case source.FieldTitle:
		m.ResetTitle()
		return nil
	case source.FieldLanguage:
		m.ResetLanguage()
		return nil
	}
	return fmt.Errorf("unknown Source field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SourceMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.parent != nil {
		edges = append(edges, source.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, source.EdgeChildren)
	}
	if m.posts != nil {
		edges = append(edges, source.EdgePosts)
	}
	if m.users != nil {
		edges = append(edges, source.EdgeUsers)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SourceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case source.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case source.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case source.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SourceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedchildren != nil {
		edges = append(edges, source.EdgeChildren)
	}
	if m.removedposts != nil {
		edges = append(edges, source.EdgePosts)
	}
	if m.removedusers != nil {
		edges = append(edges, source.EdgeUsers)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SourceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case source.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case source.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case source.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SourceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedparent {
		edges = append(edges, source.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SourceMutation) EdgeCleared(name string) bool {
	switch name {
	case source.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SourceMutation) ClearEdge(name string) error {
	switch name {
	case source.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Source unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SourceMutation) ResetEdge(name string) error {
	switch name {
	case source.EdgeParent:
		m.ResetParent()
		return nil
	case source.EdgeChildren:
		m.ResetChildren()
		return nil
	case source.EdgePosts:
		m.ResetPosts()
		return nil
	case source.EdgeUsers:
		m.ResetUsers()
		return nil
	}
	return fmt.Errorf("unknown Source edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op              Op
	typ             string
	id              *int
	email           *string
	tg_id           *int
	addtg_id        *int
	payment_info    *string
	role            *user.Role
	clearedFields   map[string]struct{}
	settings        *int
	clearedsettings bool
	sources         map[int]struct{}
	removedsources  map[int]struct{}
}

var _ ent.Mutation = (*UserMutation)(nil)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op) *UserMutation {
	return &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// ClearEmail clears the value of email.
func (m *UserMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[user.FieldEmail] = struct{}{}
}

// EmailCleared returns if the field email was cleared in this mutation.
func (m *UserMutation) EmailCleared() bool {
	_, ok := m.clearedFields[user.FieldEmail]
	return ok
}

// ResetEmail reset all changes of the email field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, user.FieldEmail)
}

// SetTgID sets the tg_id field.
func (m *UserMutation) SetTgID(i int) {
	m.tg_id = &i
	m.addtg_id = nil
}

// TgID returns the tg_id value in the mutation.
func (m *UserMutation) TgID() (r int, exists bool) {
	v := m.tg_id
	if v == nil {
		return
	}
	return *v, true
}

// AddTgID adds i to tg_id.
func (m *UserMutation) AddTgID(i int) {
	if m.addtg_id != nil {
		*m.addtg_id += i
	} else {
		m.addtg_id = &i
	}
}

// AddedTgID returns the value that was added to the tg_id field in this mutation.
func (m *UserMutation) AddedTgID() (r int, exists bool) {
	v := m.addtg_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetTgID reset all changes of the tg_id field.
func (m *UserMutation) ResetTgID() {
	m.tg_id = nil
	m.addtg_id = nil
}

// SetPaymentInfo sets the payment_info field.
func (m *UserMutation) SetPaymentInfo(s string) {
	m.payment_info = &s
}

// PaymentInfo returns the payment_info value in the mutation.
func (m *UserMutation) PaymentInfo() (r string, exists bool) {
	v := m.payment_info
	if v == nil {
		return
	}
	return *v, true
}

// ClearPaymentInfo clears the value of payment_info.
func (m *UserMutation) ClearPaymentInfo() {
	m.payment_info = nil
	m.clearedFields[user.FieldPaymentInfo] = struct{}{}
}

// PaymentInfoCleared returns if the field payment_info was cleared in this mutation.
func (m *UserMutation) PaymentInfoCleared() bool {
	_, ok := m.clearedFields[user.FieldPaymentInfo]
	return ok
}

// ResetPaymentInfo reset all changes of the payment_info field.
func (m *UserMutation) ResetPaymentInfo() {
	m.payment_info = nil
	delete(m.clearedFields, user.FieldPaymentInfo)
}

// SetRole sets the role field.
func (m *UserMutation) SetRole(u user.Role) {
	m.role = &u
}

// Role returns the role value in the mutation.
func (m *UserMutation) Role() (r user.Role, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// ResetRole reset all changes of the role field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetSettingsID sets the settings edge to UserSettings by id.
func (m *UserMutation) SetSettingsID(id int) {
	m.settings = &id
}

// ClearSettings clears the settings edge to UserSettings.
func (m *UserMutation) ClearSettings() {
	m.clearedsettings = true
}

// SettingsCleared returns if the edge settings was cleared.
func (m *UserMutation) SettingsCleared() bool {
	return m.clearedsettings
}

// SettingsID returns the settings id in the mutation.
func (m *UserMutation) SettingsID() (id int, exists bool) {
	if m.settings != nil {
		return *m.settings, true
	}
	return
}

// SettingsIDs returns the settings ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SettingsID instead. It exists only for internal usage by the builders.
func (m *UserMutation) SettingsIDs() (ids []int) {
	if id := m.settings; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSettings reset all changes of the settings edge.
func (m *UserMutation) ResetSettings() {
	m.settings = nil
	m.clearedsettings = false
}

// AddSourceIDs adds the sources edge to Source by ids.
func (m *UserMutation) AddSourceIDs(ids ...int) {
	if m.sources == nil {
		m.sources = make(map[int]struct{})
	}
	for i := range ids {
		m.sources[ids[i]] = struct{}{}
	}
}

// RemoveSourceIDs removes the sources edge to Source by ids.
func (m *UserMutation) RemoveSourceIDs(ids ...int) {
	if m.removedsources == nil {
		m.removedsources = make(map[int]struct{})
	}
	for i := range ids {
		m.removedsources[ids[i]] = struct{}{}
	}
}

// RemovedSources returns the removed ids of sources.
func (m *UserMutation) RemovedSourcesIDs() (ids []int) {
	for id := range m.removedsources {
		ids = append(ids, id)
	}
	return
}

// SourcesIDs returns the sources ids in the mutation.
func (m *UserMutation) SourcesIDs() (ids []int) {
	for id := range m.sources {
		ids = append(ids, id)
	}
	return
}

// ResetSources reset all changes of the sources edge.
func (m *UserMutation) ResetSources() {
	m.sources = nil
	m.removedsources = nil
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.tg_id != nil {
		fields = append(fields, user.FieldTgID)
	}
	if m.payment_info != nil {
		fields = append(fields, user.FieldPaymentInfo)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldTgID:
		return m.TgID()
	case user.FieldPaymentInfo:
		return m.PaymentInfo()
	case user.FieldRole:
		return m.Role()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldTgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTgID(v)
		return nil
	case user.FieldPaymentInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPaymentInfo(v)
		return nil
	case user.FieldRole:
		v, ok := value.(user.Role)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addtg_id != nil {
		fields = append(fields, user.FieldTgID)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldTgID:
		return m.AddedTgID()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldTgID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTgID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldEmail) {
		fields = append(fields, user.FieldEmail)
	}
	if m.FieldCleared(user.FieldPaymentInfo) {
		fields = append(fields, user.FieldPaymentInfo)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ClearEmail()
		return nil
	case user.FieldPaymentInfo:
		m.ClearPaymentInfo()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldTgID:
		m.ResetTgID()
		return nil
	case user.FieldPaymentInfo:
		m.ResetPaymentInfo()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.settings != nil {
		edges = append(edges, user.EdgeSettings)
	}
	if m.sources != nil {
		edges = append(edges, user.EdgeSources)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSettings:
		if id := m.settings; id != nil {
			return []ent.Value{*id}
		}
	case user.EdgeSources:
		ids := make([]ent.Value, 0, len(m.sources))
		for id := range m.sources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedsources != nil {
		edges = append(edges, user.EdgeSources)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSources:
		ids := make([]ent.Value, 0, len(m.removedsources))
		for id := range m.removedsources {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedsettings {
		edges = append(edges, user.EdgeSettings)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSettings:
		return m.clearedsettings
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeSettings:
		m.ClearSettings()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSettings:
		m.ResetSettings()
		return nil
	case user.EdgeSources:
		m.ResetSources()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// UserSettingsMutation represents an operation that mutate the UserSettingsSlice
// nodes in the graph.
type UserSettingsMutation struct {
	config
	op                Op
	typ               string
	id                *int
	urgent_words      *[]string
	banned_words      *[]string
	language          *usersettings.Language
	sending_frequency *usersettings.SendingFrequency
	last_sending      *time.Time
	clearedFields     map[string]struct{}
	user              *int
	cleareduser       bool
}

var _ ent.Mutation = (*UserSettingsMutation)(nil)

// newUserSettingsMutation creates new mutation for $n.Name.
func newUserSettingsMutation(c config, op Op) *UserSettingsMutation {
	return &UserSettingsMutation{
		config:        c,
		op:            op,
		typ:           TypeUserSettings,
		clearedFields: make(map[string]struct{}),
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserSettingsMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserSettingsMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserSettingsMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetUrgentWords sets the urgent_words field.
func (m *UserSettingsMutation) SetUrgentWords(s []string) {
	m.urgent_words = &s
}

// UrgentWords returns the urgent_words value in the mutation.
func (m *UserSettingsMutation) UrgentWords() (r []string, exists bool) {
	v := m.urgent_words
	if v == nil {
		return
	}
	return *v, true
}

// ClearUrgentWords clears the value of urgent_words.
func (m *UserSettingsMutation) ClearUrgentWords() {
	m.urgent_words = nil
	m.clearedFields[usersettings.FieldUrgentWords] = struct{}{}
}

// UrgentWordsCleared returns if the field urgent_words was cleared in this mutation.
func (m *UserSettingsMutation) UrgentWordsCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldUrgentWords]
	return ok
}

// ResetUrgentWords reset all changes of the urgent_words field.
func (m *UserSettingsMutation) ResetUrgentWords() {
	m.urgent_words = nil
	delete(m.clearedFields, usersettings.FieldUrgentWords)
}

// SetBannedWords sets the banned_words field.
func (m *UserSettingsMutation) SetBannedWords(s []string) {
	m.banned_words = &s
}

// BannedWords returns the banned_words value in the mutation.
func (m *UserSettingsMutation) BannedWords() (r []string, exists bool) {
	v := m.banned_words
	if v == nil {
		return
	}
	return *v, true
}

// ClearBannedWords clears the value of banned_words.
func (m *UserSettingsMutation) ClearBannedWords() {
	m.banned_words = nil
	m.clearedFields[usersettings.FieldBannedWords] = struct{}{}
}

// BannedWordsCleared returns if the field banned_words was cleared in this mutation.
func (m *UserSettingsMutation) BannedWordsCleared() bool {
	_, ok := m.clearedFields[usersettings.FieldBannedWords]
	return ok
}

// ResetBannedWords reset all changes of the banned_words field.
func (m *UserSettingsMutation) ResetBannedWords() {
	m.banned_words = nil
	delete(m.clearedFields, usersettings.FieldBannedWords)
}

// SetLanguage sets the language field.
func (m *UserSettingsMutation) SetLanguage(u usersettings.Language) {
	m.language = &u
}

// Language returns the language value in the mutation.
func (m *UserSettingsMutation) Language() (r usersettings.Language, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// ResetLanguage reset all changes of the language field.
func (m *UserSettingsMutation) ResetLanguage() {
	m.language = nil
}

// SetSendingFrequency sets the sending_frequency field.
func (m *UserSettingsMutation) SetSendingFrequency(uf usersettings.SendingFrequency) {
	m.sending_frequency = &uf
}

// SendingFrequency returns the sending_frequency value in the mutation.
func (m *UserSettingsMutation) SendingFrequency() (r usersettings.SendingFrequency, exists bool) {
	v := m.sending_frequency
	if v == nil {
		return
	}
	return *v, true
}

// ResetSendingFrequency reset all changes of the sending_frequency field.
func (m *UserSettingsMutation) ResetSendingFrequency() {
	m.sending_frequency = nil
}

// SetLastSending sets the last_sending field.
func (m *UserSettingsMutation) SetLastSending(t time.Time) {
	m.last_sending = &t
}

// LastSending returns the last_sending value in the mutation.
func (m *UserSettingsMutation) LastSending() (r time.Time, exists bool) {
	v := m.last_sending
	if v == nil {
		return
	}
	return *v, true
}

// ResetLastSending reset all changes of the last_sending field.
func (m *UserSettingsMutation) ResetLastSending() {
	m.last_sending = nil
}

// SetUserID sets the user edge to User by id.
func (m *UserSettingsMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *UserSettingsMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *UserSettingsMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *UserSettingsMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *UserSettingsMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the user edge.
func (m *UserSettingsMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *UserSettingsMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (UserSettings).
func (m *UserSettingsMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserSettingsMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.urgent_words != nil {
		fields = append(fields, usersettings.FieldUrgentWords)
	}
	if m.banned_words != nil {
		fields = append(fields, usersettings.FieldBannedWords)
	}
	if m.language != nil {
		fields = append(fields, usersettings.FieldLanguage)
	}
	if m.sending_frequency != nil {
		fields = append(fields, usersettings.FieldSendingFrequency)
	}
	if m.last_sending != nil {
		fields = append(fields, usersettings.FieldLastSending)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserSettingsMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case usersettings.FieldUrgentWords:
		return m.UrgentWords()
	case usersettings.FieldBannedWords:
		return m.BannedWords()
	case usersettings.FieldLanguage:
		return m.Language()
	case usersettings.FieldSendingFrequency:
		return m.SendingFrequency()
	case usersettings.FieldLastSending:
		return m.LastSending()
	}
	return nil, false
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserSettingsMutation) SetField(name string, value ent.Value) error {
	switch name {
	case usersettings.FieldUrgentWords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUrgentWords(v)
		return nil
	case usersettings.FieldBannedWords:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBannedWords(v)
		return nil
	case usersettings.FieldLanguage:
		v, ok := value.(usersettings.Language)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case usersettings.FieldSendingFrequency:
		v, ok := value.(usersettings.SendingFrequency)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSendingFrequency(v)
		return nil
	case usersettings.FieldLastSending:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastSending(v)
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserSettingsMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserSettingsMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserSettingsMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown UserSettings numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserSettingsMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(usersettings.FieldUrgentWords) {
		fields = append(fields, usersettings.FieldUrgentWords)
	}
	if m.FieldCleared(usersettings.FieldBannedWords) {
		fields = append(fields, usersettings.FieldBannedWords)
	}
	return fields
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserSettingsMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserSettingsMutation) ClearField(name string) error {
	switch name {
	case usersettings.FieldUrgentWords:
		m.ClearUrgentWords()
		return nil
	case usersettings.FieldBannedWords:
		m.ClearBannedWords()
		return nil
	}
	return fmt.Errorf("unknown UserSettings nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserSettingsMutation) ResetField(name string) error {
	switch name {
	case usersettings.FieldUrgentWords:
		m.ResetUrgentWords()
		return nil
	case usersettings.FieldBannedWords:
		m.ResetBannedWords()
		return nil
	case usersettings.FieldLanguage:
		m.ResetLanguage()
		return nil
	case usersettings.FieldSendingFrequency:
		m.ResetSendingFrequency()
		return nil
	case usersettings.FieldLastSending:
		m.ResetLastSending()
		return nil
	}
	return fmt.Errorf("unknown UserSettings field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserSettingsMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserSettingsMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case usersettings.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserSettingsMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserSettingsMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserSettingsMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, usersettings.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserSettingsMutation) EdgeCleared(name string) bool {
	switch name {
	case usersettings.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserSettingsMutation) ClearEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserSettingsMutation) ResetEdge(name string) error {
	switch name {
	case usersettings.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown UserSettings edge %s", name)
}
